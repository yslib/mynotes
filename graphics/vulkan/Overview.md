# Vulkan 总揽
---

 Vulkan相比于OpenGL，更为地层，接口更为一般化。通过观察Vulkan的接口设计我们会发现，Vulkan不希望可以进行图形绘制，在将来还要将通用计算纳入进来，所以接口设计的更加通用和复杂。

* ### 实例(vkInstance)

Vulkan实例隔离了不同的vulkan环境，在一个应用程序中，可以创建多个实例。但是实例之间的对象不能共享，如内存。（在不涉及扩展的情况下）
实例具有以下功能：

1. 枚举当前环境支持的扩展。
2. 是否启用扩展：真正启用扩展的地方是在创建逻辑设备的时候，但是是否允许开启扩展的地方是在创建实例时。
3. 是否开启验证层：包括调试回调。调试回调也属于扩展。
4. 指定全局内存分配器：Vulkan提供了一个全局内存分配器回调，让用户可以接管Vulkan对象的所需要使用主机端的内存的分配。

* ### 物理设备对象(vkPhysicalDevice)

在初始化Vulkan的物理设备时，除了选择需要的物理设别外，还应该获取关于物理设备的一些属性供之后使用：

1. 格式：包括交换链格式，图像格式和深度格式，以及深度模板格式。因为这些格式（例如R8G8B8A8）都是硬件级别支持的，所以需要询问物理设备是不是支持。
2. 最大采样数：反走样的采样数。
3. 设备内存：Vulkan的内存类型比较复杂，任何需要设备内存的对象的创建都需要指定内存类型。如Image和Buffer。内存类型有很多，并且每种类型都由某种类型的堆负责创建。
   当使用vkGetPhysicalDeviceMemoryProperty 查询相应物理设备支持的内存时，获取到的内存属性包括两个数组。第一个是支持的内存类型，
   第二个是支持的内存堆。支持的内存类型是由一系列bitflags决定的，并且支持的内存类型里还包括了一个索引，这个索引就是由相应支持分配
   的堆所在数组的索引。

   内存类型标志位大概有这几种类型：（其余见官方规范手册）

>DEVICE_LOCAL_BIT： 设备专用内存，一般是纹理或者顶点缓冲使用的内存

>HOST_VISIBLE_BIT： 主机可见内存，表明内从可以被主机端映射，可以在主机端像访问CPU内存一样直接存取

>COHERENT_BIT：对于主机可见内存的访问保持一致性，否则需要手动更新内存。

>HOST_CACHED_BIT：这种内存会缓存在cpu端，但是主机端的访问可能会慢一些。

>LAZILY_ALLOCATED_BIT：延迟分配。
   这几种并不是随意组合的，合法的组合请参照Vulkan规范手册

   堆类型标志位大概由这几种类型：（其余见官方规范手册）

>DEVICE_LOCAL_BIT: 设备中的堆，一般位于是运行Vulkan的硬件设备，比如GPU。这种就是大多数情况。

>MULTI_INSTANCE_BIT: 当一个逻辑设备是由多个物理设备构成时，分配内存的时候会重复分配到每个物理设备中。（用在分布式上？）

4. 支持的队列族：同样也用索引来标识，创建逻辑设备时需要指定。队列也是不同于之前传统API的新特性。

* ### 逻辑设备(vkDevice)

逻辑设备是Vulkan对物理设备的抽象。可以从一个物理设备上创建多个逻辑设备。逻辑设备对象负责vulkan的设备资源分配。
负责的主要功能有：

1. 开启扩展：

     如果需要窗口显示功能，这里需要开启交换链扩展

2. 指定设备要用到的队列：如果需要绘制流水线功能就指定图形队列，如果要使用计算着色器的功能，就指定计算队列。
3. 获取队列：只能获取创建时指定的队列，而支持什么样的队列需要通过物理设备进行查询。

* ### 表面（vkSurfaceKHR, 扩展）

表面是展示渲染结果的那个对象，可以不严谨地理解为呈现绘制结果的那个窗口区域。表面不是Vulkan核心的一部分。因为显示窗口不具备跨平台性，所以vulkan没有义务去做这个限制。
（其实OpenGL也没有）。首先查询物理设备的队列族是不是支持表面。输入参数为物理设备和所使用的队列族索引。
创建表面需要从实例创建，创建表面除了需要实例，还需要一个显示表面的窗口句柄，这个窗口句柄取决于平台。

* ### 平面(Plane,扩展)×

* ### 交换链(vkSwapchainKHR, 扩展)

交换链提供和管理表面中的数据，一般情况下是一个环形的缓冲，一些表面用来显示在窗口上，一些表面用来接受绘制的结果供接下来的展示用。
不严谨地说就是帧缓冲的管理器。为什么不严谨，因为表面的数据不是Vulkan所管理的，而是操作系统。
创建交换链需要指定之前创建的表面以及逻辑设备。因此交换链是被逻辑设备所拥有的。

* 缓冲(VkBuffer)

  与OpenGL中glCreateBuffer创建出来的对象等价。需要指名Buffer 的用法。与opengl不同的是，这里创建好的buffer没有内存，需要绑定到另外的内存对象上。

× 图像(VkImage)

  在Vulkan 里创建图像的一般方式也是先把图像数据放入暂存缓冲，然后从暂存缓冲复制到GPU中。然而与OpenGL不同的是这里的图像需要指定
  图像布局(ImageLayout)。图像布局描述了当前图像所扮演的角色。图像的布局大概分为一下几种：
  1. PRESENT (VK_IMAGE_LAYOUT_PRESENT_SRC_KHR): 用来作为呈现图像，这个布局可以绘制到屏幕上。

  2. 



# GLSL in Vulkan
---

Vulkan只支持SPIR-V,一种JIT执行的中间语言。但是现有的很多高级着色语言都可以通过工具翻译成SPIR-V。有些驱动支持GLSL扩展，可以直接在Vulkan中
使用GLSL，但这是不推荐使用的非主流用法。

一般情况下，转换为SPIR-V的GLSL也和OpenGL里的GLSL有些不同。在这里主要记录一下不同的地方。

1. 所有的非透明对象必须放在uniform block里。

2. 
```
gl_VertexID 改为 gl_VertexIndex
gl_InstanceID 改为 gl_InstanceIndex
```
2. 所有的变量声明都需要布局操作符。在OpenGL里也推荐使用布局操作符，所有行为都需显式指定，这也是Vulkan的特点之一。


>这里有一篇讲如何将OpenGL 移植到Vulkan 上的实践。就算不使用Vulkan,在OpenGL里也应该这样使用。
>https://on-demand.gputechconf.com/gtc/2016/events/vulkanday/Migrating_from_OpenGL_to_Vulkan.pdf

