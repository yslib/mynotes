<!doctype html><html lang=en><head><title>When do you need other smart pointer instead of std::shared_ptr? :: YSL Blog</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Most C++ programmers known more or less about std::shared_ptr, but what is its limitations?
"><meta name=keywords content="Blog,Personal Website"><meta name=robots content="noodp"><link rel=canonical href=/post/dev/smartpointer/><link rel=stylesheet href=/styles.css><link rel="shortcut icon" href=/img/theme-colors/white.png><link rel=apple-touch-icon href=/img/theme-colors/white.png><meta name=twitter:card content="summary"><meta name=twitter:site content><meta name=twitter:creator content><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="og:title" content="When do you need other smart pointer instead of std::shared_ptr?"><meta property="og:description" content="Most C++ programmers known more or less about std::shared_ptr, but what is its limitations?
"><meta property="og:url" content="/post/dev/smartpointer/"><meta property="og:site_name" content="YSL Blog"><meta property="og:image" content="/img/favicon/white.png"><meta property="og:image:width" content="1200"><meta property="og:image:height" content="627"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script></head><body class=white><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>YSL Blog</div></a></div><ul class="menu menu--mobile"><li class=menu__trigger>Menu&nbsp;▾</li><li><ul class=menu__dropdown><li><a href=/about/>About Me</a></li><li><a href=https://github.com/yslib>GitHub</a></li><li><a href=https://picysl.com>Photography</a></li></ul></li></ul></div><nav class=navigation-menu><ul class="navigation-menu__inner menu--desktop"><li><a href=/about/>About Me</a></li><li><a href=https://github.com/yslib>GitHub</a></li><li><a href=https://picysl.com>Photography</a></li></ul></nav></header><div class=content><article class=post><h1 class=post-title><a href=/post/dev/smartpointer/>When do you need other smart pointer instead of std::shared_ptr?</a></h1><div class=post-meta></div><div class=post-content><div><p>Most C++ programmers known more or less about <code>std::shared_ptr</code>, but what is its limitations?</p><p>C++ standard library smart pointer <code>std::shared_ptr</code> is based on the RAII and reference counting, an ingenious way to manange memory than C. As long as be careful with the circular reference (not 100% to avoid them virtually), you can always coding without too much concerns.</p><p>Supposed you need to manage a DAG, which is very common in organizing software architecture. Usually, DAG would be used along with Observer Pattern. Since one need to response to changes or events from its dependencies. It has a bidirectional link between one node and its successor.</p><figure class=center><img src=./img/dag.drawio.svg alt=DAG style=border-radius:8px;width:400px><figcaption class=center>DAG</figcaption></figure><p>It&rsquo;s okay in a programming with GC, but in C++, there is usually a strong reference point (solid arrow in the chart) to its successor and at the same time, a weak reference point to the predecessor. (dash arrow in the chart) in order to avoid cycling referencing.</p><p>Saying that you want to create two objects with this kind of relationship as the fowlling chart, you may allocate one successor and observe it immediately after it being created in constructor, which is straightforward.</p><figure class=center><img src=./img/two.drawio.svg alt=DAG style=border-radius:8px;width:100px><figcaption class=center>cycling reference</figcaption></figure><p>The code is like this</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Node</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> std<span style=color:#f92672>::</span>enable_shared_from_this<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>&gt;</span> {
</span></span><span style=display:flex><span>  std<span style=color:#f92672>::</span>vector<span style=color:#f92672>&lt;</span>std<span style=color:#f92672>::</span>weak_ptr<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>&gt;&gt;</span> subscribers;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>observe</span>(std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>&gt;</span> sub) {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... do some check
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    sub<span style=color:#f92672>-&gt;</span>subscribers.push_back(<span style=color:#66d9ef>this</span><span style=color:#f92672>-&gt;</span>shared_from_this());
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Bar</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Node {};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Foo</span> <span style=color:#f92672>:</span> <span style=color:#66d9ef>public</span> Node {
</span></span><span style=display:flex><span>  std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>Node<span style=color:#f92672>&gt;</span> object2;
</span></span><span style=display:flex><span>  Foo(std<span style=color:#f92672>::</span>shared_ptr<span style=color:#f92672>&lt;</span>Bar<span style=color:#f92672>&gt;</span> observed ) {
</span></span><span style=display:flex><span>    object2 <span style=color:#f92672>=</span> observed;
</span></span><span style=display:flex><span>    observe(std<span style=color:#f92672>::</span>move(observed));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() { <span style=color:#66d9ef>auto</span> object1 <span style=color:#f92672>=</span> std<span style=color:#f92672>::</span>make_shared<span style=color:#f92672>&lt;</span>Foo<span style=color:#f92672>&gt;</span>(std<span style=color:#f92672>::</span>make_shared<span style=color:#f92672>&lt;</span>Bar<span style=color:#f92672>&gt;</span>); }
</span></span></code></pre></div><p>If you run the code, it will throw <code>std::bad_weak_ptr</code> and terminate the program. The reason is that the object2 is not constructed yet when the <code>shared_from_this</code> is called in the constructor of Foo. So the weak reference is not constructed yet. That&rsquo;s the limitation of <code>std::shared_ptr</code> when it comes to this case. You may even notice that using <code>auto object1 = std::make_shared&lt;Foo>()</code> to create a shared object needs two steps rather than one. The first step is construct the object itself, and the second step, creating <code>shared_ptr&lt;T></code> wrapper and putting the object into it.</p><p>It&rsquo;s so often that observing another object in one object&rsquo;s constructor. You definitely could achieve it using <code>std::shared_ptr</code>, but it&rsquo;s verbose when you need to deal with massive kind of this DAG network.
So when your system heavily relies on this kind of DAG, you need another smart pointer to help you out.</p><p>That&rsquo;s what intrusive smart pointer does. It&rsquo;s a smart pointer that doesn&rsquo;t allocate memory for the reference count, but put the reference count in the object itself. It&rsquo;s intrusive because it needs to modify the object itself to add the reference count. It&rsquo;s a trade-off between memory and performance. It&rsquo;s more efficient than <code>std::shared_ptr</code> in terms of memory usage and performance. But it&rsquo;s less flexible than <code>std::shared_ptr</code> because it needs to modify the object itself. Usually it&rsquo;s not a problem because when you need it, it means that you system is designed on purpose, the cost of instrusive modification is such a small part compared to the whole system.</p><p>The intrusive pointer don&rsquo;t support weak reference counting by default. Thinking a weak pointer means that when when the strong reference count is 0 and the weak reference count is not 0, the object should be destroyed according to the weak reference counting semantic. But also according to the definition of intrusive, if the object is destroyed, the counters in the object should be destroyed as well. So you cannot put the counter inside the object directly if you want to support weak reference counting. You need to put the counter outside the object, and the object should be able to access the counter. It&rsquo;s a little bit tricky, but it&rsquo;s doable. You just put the strong/weak counting part all together out of the object itself and point to it.</p><figure class=center><img src=./img/diagram.drawio.svg alt=ref_ptr style=border-radius:8px;width:8000px><figcaption class=center>smart pointer layout</figcaption></figure><p>The interface of <em><strong>RefCnt</strong></em> is straight forward and intuitive.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c++ data-lang=c++><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>RefCnt</span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> ref() <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>deref</span>() <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>ref_weak</span>() <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>virtual</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>deref_weak</span>() <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>virtual</span> size_t <span style=color:#a6e22e>ref_count</span>() <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>virtual</span> size_t <span style=color:#a6e22e>ref_weak_count</span>() <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>You can implement of your own <code>RefCnt</code> by inheriting from it. In most senarios, you can using <code>final</code> keyword and give the most-concret instance to eliminate the cost of virtual call.</p><p>Here is the <a href=https://github.com/yslib/ref_ptr>implementation</a>.</p></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>Read other posts</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=/post/graphics/vulkan/><span class=button__icon>←</span>
<span class=button__text>\[Rendering\] Introduction to Vulkan</span></a></span></div></div></article></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2024 Powered by <a href=https://gohugo.io>Hugo</a></span>
<span>:: <a href=https://github.com/panr/hugo-theme-terminal target=_blank>Theme</a> made by <a href=https://github.com/panr target=_blank>panr</a></span></div></div></footer><script type=text/javascript src=/bundle.min.js></script></div></body></html>